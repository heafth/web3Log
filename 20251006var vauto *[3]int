对于go语言中 * ，& 符号的理解和运用
1. 指针类型的情况
var vauto *[3]int
vauto 是一个“指向 [3]int 的指针”。
*vauto 解引用，表示“vauto 指向的那个数组”。

2. 普通变量（非指针类型）的情况
var vauto2 [3]int
这里 vauto2 就是一个 数组值，不是指针。

声明和初始化时：
 * 写在 类型 前：表示“这是个指针类型”。
 * 写在 变量或表达式 前：表示“解引用”，取指针指向的值。
 如果变量本身不是指针（例如 int、[3]int），那写 *变量 会直接报错。
在方法调用时：
 参数/接收者写成 *T，就是想让函数能修改调用者的值。
 调用方要传 &变量，或者 Go 编译器能帮你自动取地址。


*vauto = vstat → 拷贝数组内容。
    结果：堆上的那块 [3]int 内存现在和 vstat 内容一致。
         但是！它们是 两份独立的数组。
         改 vstat 不会影响 *vauto。
         改 *vauto 也不会影响 vstat。
vauto = &vstat → 改变指针指向。
    结果：vauto 不再指向堆上那份数组，而是直接指向 vstat。
         它们现在共享同一个数组。
         改 vstat 就会影响 *vauto。
         改 *vauto 也会影响 vstat。


2. Go 的内存分区
  1、代码区 (text segment)：程序的指令。
  2、全局/静态区 (data segment)：全局变量、常量。
  3、栈 (stack)：局部变量，函数调用。
  4、堆 (heap)：动态分配的对象，逃逸到堆的数据。



  大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要减少类似操作避免影响程序的性能


“逃逸”的直观理解
  没逃逸 → 变量生命周期只在函数内，用完函数结束就没了，可以放在栈上。
  逃逸了 → 变量在函数返回后还要被使用，必须放堆上交给 GC 管理。
