errgroup.Group 是 Go 语言里一个方便的“多个并发任务一起做、等它们都完成、还要处理错误”的工具。来自扩展包

Semaphore信号量在并发编程里是一种“计数型”的工具，用来管理同时访问某个资源的数量。想像一下：“我这台机器最多允许 10 个人同时访问”；那么第 11 个人就要等前面有人退出来，才可以进去。这个“最多 10 人”的机制就是信号量的典型场景。

“singleflight”这个名字其实可以拆开理解：single（单一） + flight（正在进行的请求／任务）。它的作用是：对于“某个键（key）”对应的任务，同一时刻只让一个真正执行，其它发起同样任务的请求等它完成，然后都共享这个结果。

计时器：
  1、重置计时器时，必须确保计时器尚未触发，否则可能导致意外行为。
  2、重置后的计时器会覆盖之前的触发时间。

  Go 语言中的计时器主要由以下两个结构体组成：
   1、time.Timer：对外暴露的计时器类型，包含一个接收时间的通道（C）和一个内部的 runtimeTimer。
   2、runtimeTimer：内部使用的计时器类型，包含计时器的状态、触发时间、周期等信息。

Go 语言中的计时器采用状态机管理，主要状态包括：
   timerNoStatus	         还没有设置状态
   timerWaiting	           等待触发
   timerRunning	           运行计时器函数
   timerDeleted	           被删除
   timerRemoving	         正在被删除
   timerRemoved	           已经被停止并从堆中删除
   timerModifying	         正在被修改
   timerModifiedEarlier	   被修改到了更早的时间
   timerModifiedLater	     被修改到了更晚的时间
   timerMoving	           已经被修改正在被移动

 7种操作：
   runtime.addtimer — 向当前处理器增加新的计时器8；
   runtime.deltimer — 将计时器标记成 timerDeleted 删除处理器中的计时器9；
   runtime.modtimer — 网络轮询器会调用该函数修改计时器10；
   runtime.cleantimers — 清除队列头中的计时器，能够提升程序创建和删除计时器的性能11；
   runtime.adjusttimers — 调整处理器持有的计时器堆，包括移动会稍后触发的计时器、删除标记为 timerDeleted 的计时器12；
   runtime.runtimer — 检查队列头中的计时器，在其准备就绪时运行该计时器13；

 runtime.modtimer 与  runtime.adjusttimers 区别：
   modtimer 会接收一个 timer 对象和新的到期时间。如果定时器已经在运行队列中，modtimer 会把它从原来的位置移除，然后重新插入到正确的位置（按新的时间排序）。
   当系统时间发生跳变（例如 time.Now() 突然变大或变小）或者需要调整全局定时器队列时，runtime 会调用 adjusttimers。它会遍历整个定时器堆，把所有定时器的到期时间加上或减去一个偏移量。

timerRemoving 与 timerRemoved 与 timerDeleted区别：
  timerRemoving：临时状态，防止并发操作冲突
  timerRemoved：停止且从堆里移除，但对象还可复用
  timerDeleted：最终状态，彻底无效
  
timer in heap (timerWaiting)
    │
    │ Timer.Stop()
    ▼
timerDeleted       <-- 标记删除（逻辑删除），还可能在堆中
    │
    │ 清理过程
    ▼
timerRemoving      <-- 正在从堆中物理移除
    │
    ▼
timerRemoved       <-- 已从堆中移除完成，可以 Reset


 
