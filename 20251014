defer 关键字调用时就会计算， 如果不想那样，我们只需要向 defer 关键字传入匿名函数
例如
结果在调用时就计算：
  defer fmt.Println(time.Since(startedAt))   
结果在程序执行退出前，随着defer的执行就计算:
  defer func() { fmt.Println(time.Since(startedAt)) }() 


defer选着使用开放编码的使用条件
 1、函数的 defer 数量少于或者等于 8 个；
 2、函数的 defer 关键字不能在循环中执行；
 3、函数的 return 语句与 defer 语句的乘积小于或者等于 15 个；

 
 开放编码-延迟记录： 
    一旦决定使用开放编码，cmd/compile/internal/gc.buildssa 会在编译期间在栈上初始化大小为 8 个比特的 deferBits 变量：
 开放编码-延迟比特：
    延迟比特的作用就是标记哪些 defer 关键字在函数中被执行，这样在函数返回时可以根据对应 deferBits 的内容确定执行的函数，
  而正是因为 deferBits 的大小仅为 8 比特，所以该优化的启用条件为函数中的 defer 关键字少于 8 个


defer 关键字的实现主要依靠编译器和运行时的协作，我们总结一下本节提到的三种机制：

堆上分配 · 1.1 ~ 1.12
  编译期将 defer 关键字转换成 runtime.deferproc 并在调用 defer 关键字的函数返回之前插入 runtime.deferreturn；
  运行时调用 runtime.deferproc 会将一个新的 runtime._defer 结构体追加到当前 Goroutine 的链表头；
  运行时调用 runtime.deferreturn 会从 Goroutine 的链表中取出 runtime._defer 结构并依次执行；
栈上分配 · 1.13
  当该关键字在函数体中最多执行一次时，编译期间的 cmd/compile/internal/gc.state.call 会将结构体分配到栈上并调用 runtime.deferprocStack；
开放编码 · 1.14 ~ 现在
  编译期间判断 defer 关键字、return 语句的个数确定是否开启开放编码优化；
  通过 deferBits 和 cmd/compile/internal/gc.openDeferInfo 存储 defer 关键字的相关信息；
  如果 defer 关键字的执行可以在编译期间确定，会在函数返回前直接插入相应的代码，否则会由运行时的 runtime.deferreturn 处理；

后调用的 defer 函数会先执行：
  后调用的 defer 函数会被追加到 Goroutine _defer 链表的最前面；
  运行 runtime._defer 时是从前到后依次执行；
函数的参数会被预先计算；
  调用 runtime.deferproc 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；


----------------------------------------------------------------------------------------------------------------------------------
panic 只会触发当前 Goroutine 的 defer；
recover 只有在 defer 中调用才会生效；
panic 允许在 defer 中嵌套多次调用；

1、编译器会负责做转换关键字的工作；
  1.1、将 panic 和 recover 分别转换成 runtime.gopanic 和 runtime.gorecover；
  1.2、将 defer 转换成 runtime.deferproc 函数；
  1.3、在调用 defer 的函数末尾调用 runtime.deferreturn 函数；
2、在运行过程中遇到 runtime.gopanic 方法时，会从 Goroutine 的链表依次取出 runtime._defer 结构体并执行；
3、如果调用延迟执行函数时遇到了 runtime.gorecover 就会将 _panic.recovered 标记成 true 并返回 panic 的参数；
  3.1、在这次调用结束之后，runtime.gopanic 会从 runtime._defer 结构体中取出程序计数器 pc 和栈指针 sp 并调用 runtime.recovery 函数进行恢复程序；
  3.2、runtime.recovery 会根据传入的 pc 和 sp 跳转回 runtime.deferproc；
  3.3、编译器自动生成的代码会发现 runtime.deferproc 的返回值不为 0，这时会跳回 runtime.deferreturn 并恢复到正常的执行流程；
4、如果没有遇到 runtime.gorecover 就会依次遍历所有的 runtime._defer，并在最后调用 runtime.fatalpanic 中止程序、打印 panic 的参数并返回错误码 2；
