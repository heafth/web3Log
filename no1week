区块链 链式数据结构 不可篡改性和不可伪造性 
所有的数据，存在于每一个节点上，且数据保持一致，要修改都修改
区块链 1.0 -- 数字货币 2.0 -- 智能合约 3.0--超越货币、经济和市场

  维度	                 公链	                      私链	                   联盟链
节点准入	          无门槛，任何人可加入	       严格授权，单一主体控制	      联盟内机构授权加入
去中心化程度	          完全去中心化	                完全中心化	          半去中心化（多主体共治）
共识参与者	          所有节点共同参与	           单一主体指定节点	         联盟内节点共同参与
效率	            低（节点多，共识慢）	        高（节点少，控制集中）	     中（节点数量适中）
典型应用	            比特币、以太坊	              企业内部数据管理	       跨境支付、供应链协同

共识算法 (就是分布式系统的 “投票规则”，让一群不可靠的节点，最终能就 “一件事” 达成相同的结论)
  PoW 通过此算法出题并广播给所有节点让所有节点进行计算，那个节点先计算出来，便奖励比特币
  PoS 就是让持币多的人，拿一部分币做抵押，然后让他继续负责挖币，成功概率大
  DPoS 投票出一定数量的“代表”，也称为见证人或出块人。这一过程类似于股东大会投票选董事会代表股东管理公司。

拜占庭容错
  比如一个队伍几个人他们本应该都做出同样的决定，比如要进攻都进攻，要撤退都撤退，但是他们之间是点到点告知自己的到底是同意进攻还是撤退，
万一中间有一个人是叛徒，或者几个人是叛徒，就可以存在故意捣乱的情况，造成大家误以为同意的人认为同意的人多，不同意的人以为不同意的人多，
最后部队就分散了，就出现严重的问题。

嵌入式数据库 (直接部署在自己的机器上而不是服务器)
  高效率：嵌入式数据库直接通过应用程序调用 API 进行数据操作，无需运行独立的数据引擎。
  体积小巧：最初为嵌入式系统设计，嵌入式数据库的体积较小，占用资源少，包括 ROM、RAM 和 CPU。
  功能全面：尽管体积小，但功能完备，包括日志管理、数据压缩、备份及恢复等。
  高可移植性：与关系型数据库相比，嵌入式数据库具有更好的兼容性，适用于多种软硬件平台

智能合约 
  区块链平台上 条件被满足时自动执行合约

区块链应用
 1保险理赔
  使用智能合约，只要满足理赔条件，即可自动执行保单理赔，无需投保人申请或保险公司批准。
 2跨境支付
  交易周期长、成本高和透明度低 支付可以绕过第三方支付机构
 3数字货币
  匿名性和安全性： 相比纸币，数字货币减少了匿名交易的风险，降低了伪造和洗钱的可能。
  需求匹配： 传统的电子支付系统通常与银行账户紧密相关，不能完全满足用户对匿名支付的需求。
  成本和便携性： 与纸币和硬币相比，数字货币的制造和流通成本更低，携带更加便利。
  数字货币使得货币创造、记账和流通的数据能够实时采集，并通过大数据等技术手段在数据脱敏后进行深入分析

价值互联网
  安全地促进价值的直接传输和交易，无需依赖传统的中介机构，提高交易效率，还能降低交易成本，并增强交易的透明度和安全性

共享经济
  解决了传统共享经济中存在的信任危机和中心化运作的问题

物联网和物流领域中的区块链应用
  有效降低物流成本，提高供应链管理的透明度和效率，并实现从生产到运输过程中每一步的追溯。

数字存证和版权领域
  有效地鉴定和验证文字、视频、音频等数字作品的原创性和所有权，确保作品权属的真实性和唯一性。

公益领域
  便于公众透明查看和社会监督

溯源、防伪与供应链方向
  溯源技术指的是追踪和记录商品或信息从源头到消费者的整个流转过程。这一过程通过详细记录每一次商品的流转，以及支持供应链金融服务等

去中心化存储方向
  1医疗应用 患者随时随地都能访问自己的医疗记录
  2DNS系统 区块链的共识机制确保用户获得的地址信息准确无误，从而防止用户被导向虚假网站和遭受诈骗

知名开源区块链项目
  1超级账本（Hyperledger） 它并不是一个区块链应用，而是一个包含构建区块链所需工具集合的项目；Fabric 是其核心实现
  2以太坊 (Ethereum) 以太坊是一个公链项目，也是由 Go 语言实现，同时它还催生了另一个高级语言 Solidity，专门用来写智能合约

两阶段提交
   第一阶段： 事务管理器 向各个节点发送请求 执行事务并要求回复是否可以提交事务。
   第二阶段： 当所有节点都回复yes的时候，执行提交命令，否则执行回滚命令，不管提交还是回滚最后 所有节点都要回复确认，随后事务标记完成

三阶段提交 其实就是把两阶段提交的第一阶段拆成两份
   第一阶段： 发送预执行的请求
   第二阶段： 节点将事务的 undo 和 redo 日志写入稳定存储后执行事务回复“Yes”或“No”
   第三阶段： 如果都回复成功则执行提交，如果失败或者超速则执行回滚

通信模型
   同步模型 即必须等待对方回复比如打电话必须等对方拿起电话才能通讯  所有通信延迟有明确的、预定义的上限，如果超过这个上限，直接认为对方节点故障（而非 “延迟”）
   异步模型 类似于发邮件，发送完了，不用等待对方回复，干自己的事 完全不设通信延迟上限。消息可能瞬间到达，也可能延迟几小时、几天，甚至永远丢失
   部分同步模型 类似于微信，发送完了消息，对方可能马上就看到并且回复，也可能很久都没看到 延迟没有永久的上限，但存在 “最终会稳定在某个上限内” 的特性。

FLP 定理 在一个异步通信网络中，只要存在一个故障节点，就不存在一种完美的共识算法可以正确地终止（使所有节点达成一致）
CAP 定理 一个系统不可能同时满足以下三个属性 强一致性 可用性 分区容错性

共识算法分类
  容错类型
    拜占庭容错共识算法：包括 PBFT、PoW（工作量证明）、PoS（权益证明）、DPoS（委托权益证明）等。这类算法能够在节点可能存在恶意行为的环境中维持网络的一致性和安全。
    非拜占庭容错共识算法：如 Paxos、Raft 等。这些算法假设节点基本诚实，主要解决的是因网络故障或节点失效导致的问题。
  算法确定性
    确定性共识算法：如 Paxos、Raft、PBFT 等。这些算法一旦达成共识，其决策就是最终的，不存在回退的可能性。
    概率性共识算法：如 PoW、部分 PoS 等。这类算法达成的共识可能会在未来某个时间点被回退，但这种概率随时间延长逐渐趋近于零。
  选主策略
    选举类共识算法：如 Raft、PBFT。这些算法通过节点间的投票机制来选举出块节点，选举出的节点可以在多轮中连续作为出块节点。
    证明类共识算法：如 PoW、PoS。这些算法要求节点通过展示其计算能力或持有的货币量等方式来赢得出块的权利，通常每轮选举的出块节点都是不同的，以增强系统的公平性和安全性。

传统分布式一致性算法
  Basic Paxos 主要处理单一决策值的一致性问题。
  Multi Paxos 扩展到连续的多值决策，提高了处理连续事务的效率。
  Raft 是基于 Multi Paxos 思想的变体，以其易理解性和易实现性而受到青睐。
    
区块链共识算法
  公链项目，考虑节点规模和安全性。通常选择能够容忍拜占庭故障的共识算法，如 PoW、Pos、DPoS 等；
  联盟链和私链项目，更考虑高性能和低延迟。通常选择经典 PBFT、Raft 等。

PBFT 算法 又称实用拜占庭容错
  主要应用在节点较少，且要求高吞吐量的区块链系统中，如联盟链和私链，算法中主要运行三类基本协议：一致性协议、检查点协议和视图更换协议。


一、对称密码算法
 流密码以数据流的形式逐位或逐字节加密，而分组密码则将数据分成固定大小的块进行加密
 知名的对称密码算法包括：
  DES（Data Encryption Standard）： 较老的加密标准，现已被认为不够安全。
  3DES（Triple DES）： 是 DES 的一个更安全的变体，通过三次加密过程增强安全性。
  IDEA（International Data Encryption Algorithm）： 一种强大的加密算法，常用于商业加密软件。
  RC2, RC4, RC5： 由 Ron Rivest 设计的一系列加密算法，其中 RC4 尤其流行，虽然现在被认为存在安全性问题。
  Blowfish： 是一种块加密算法，设计用来替代 DES。
  AES（Advanced Encryption Standard）： 现代加密标准，提供了高级的安全性，是目前使用最广泛的加密算法之一。
  1. 流密码
  RC4：曾广泛用于 WEP 网络加密。
  SNOW 3G：在 3G 数据传输中用作加密算法。
  A5：用于 GSM 系统的加密。
  祖冲之序列密码：在 4G 通信中用于加密。

分组密码
 分组密码是一种将长明文序列切分为固定长度段后，对每个段分别进行加密的方法
分组密码工作模式
 分组密码工作模式不是一种加密算法，而是描述如何在一个加密算法中重复使用密钥的方法
总结：
 分组密码（如 AES、DES）：定义了 “单块加密的具体算法”（核心工具）。
 分组密码工作模式：定义了 “如何把单块加密算法组合起来，处理任意长度的数据”（使用工具的策略）。

对称密码算法小结
 对称密码算法的主要优势在于其开放性、低计算需求、快速加密速度和高加密效率 
 缺点是安全性高度依赖于其保存方式，如果密钥由多人知晓，泄露的风险显著增加

对称密码算法在区块链中的应用
 数字钱包中的私钥管理
 区块链网络层通信

二、非对称密码算法又称公钥加密算法
 使用一对密钥：一个公钥和一个私钥。这两个密钥具有互补性，即用其中一个密钥加密的信息，只能用另一个相应的密钥解密

三、Hash 函数
 任意长度的输入数据转换成固定长度输出的函数。这些输出通常表现为一个较短的、固定长度的值或摘要，常用于确保数据的完整性。
 哈希函数的特点是高效且能快速地处理大量数据，同时其输出不易被逆向工程还原原始输入信息
 常见 Hash 函数有 MD4/MD5、RipeMD-160、SHA 系列函数以及 SM3 国密算法
 区块链使用的是SHA-256 算法

四、PKI
 1.公钥基础设施（PKI）是一种综合性的框架，设计用于支持公钥加密和数字证书的管理。它包含了硬件、软件、人员、政策和程序等多个组成部分，
 涵盖密钥和数字证书的生成、管理、存储、分发以及撤销等全方位功能
 2.证书颁发机构（CA）是公钥基础设施（PKI）的信任基础。CA 负责发放数字证书、设置证书的有效期、管理证书吊销列表（CRL）以实现证书的吊销、
 管理用户密钥等任务。CA 掌管公钥的整个生命周期，涵盖签发、吊销和更新数字证书等各个环节。
 PKI 应用
  VPN（虚拟专用网络）：通过 PKI 实现安全的远程访问，利用数字证书验证用户身份，并建立加密通信通道。
  TLS（传输层安全协议）：保护互联网通信安全，基于 PKI 的数字证书进行服务器和客户端的身份验证，然后通过非对称加密完成密钥协商，确保数据传输的机密性和完整性。

五、Merkle 树
 Merkle 树，也称为哈希树，是一种用于存储哈希值的数据结构，原始大数据块被分割成多个小数据块以实现分布式下载，最终合成完整的大数据块。
 通过构造哈希列表，可以有效地校验多个小数据块的完整性
 一个区块内的merkle树会记录整个区块的所有交易，不是整个区块链的所有交易，具有验证交易真实性防止篡改交易结果的重要性
篡改底层交易（如 Alice 到 Bob 这笔交易），其哈希值会改变，由此向上计算的各层节点哈希值都会变化，导致最终与原本的根节点哈希值不匹配，从而能检测出数据被篡改。

六、数字签名技术
 数字签名技术利用私钥对数据进行加密运算，生成一串字符，以替代手写签名或印章。它用于确认消息来源，防止欺诈或消息伪造。

七、零知识证明（Zero—Knowledge Proof，ZKP）
 零知识证明（ZKP）是在 20 世纪 80 年代初提出的，它允许证明者向验证者证明自己拥有某个秘密，而不泄露该秘密本身，即向外界透露的「知识」为零。零知识证明分为交互式和非交互式两种类型
   1. 交互式零知识证明（Interactive Zero-Knowledge, IZK）
交互式零知识证明是指证明者和验证者双方按照一个协议，通过一系列交互，最终验证者能够得出一个明确的结论，即证明者是否掌握某个秘密。
   2. 非交互式零知识证明（Non-Interactive Zero-Knowledge, NIZK）
交互式零知识证明（IZK）协议依赖于验证者的随机尝试，需要证明者和验证者进行多次交互才能完成验证。而非交互式零知识证明（NIZK）将交互次数减少到一次，实现了离线证明和公开验证。

 区块链如何应用零知识证明
在比特币交易过程中，为验证一笔交易是否合法，实际上只需验证以下三件事：
 发送方确实拥有足够的资金。
 发送方转出的金额和接收方收到的金额一致。
 发送方的资金确实被销毁。
在整个证明过程中，矿工实际上并不关心具体的交易金额、发送者身份或接收者身份。矿工只关心系统中的资金是否守恒。Zcash（大零币）正是基于这一思路，实现了隐私交易。

Base58 编码方案
 相比于 Base64，Base58 去掉了 6 个易混淆的字符：数字 0、大写 O、小写 l、大写 I 以及 +/，以便在任何字体中都能肉眼区分这些字符。

比特币交易：
  发送者（如 A）、接收者（如 B）
  1. 发送者 A 的操作：生成可验证的交易凭证
   组合核心信息：将「A 获取该货币的上一次交易哈希值」+「接收者 B 的公钥（即 B 的收款地址）」按固定顺序拼接；
   计算哈希值：用 SHA-256 算法对上述拼接信息计算，得到一个唯一的 “组合哈希值”；
   数字签名：A 用自己的私钥对 “组合哈希值” 签名（相当于 A 的 “数字印章”，证明交易是 A 发起）；
   广播交易：A 将「上一次交易哈希值」「B 的公钥」「A 的签名」一起发送给 B，同时同步到区块链网络。
  2. 接收者 B 的验证：确认交易合法有效
   解密签名：B 用发送者 A 的公钥解密 A 的 “数字签名”，得到解密后的 “原始组合信息”（即 A 当初拼接的「上一次交易哈希值 + B 的公钥」）；
   重新计算哈希：B 按 A 完全相同的规则（相同顺序拼接、相同 SHA-256 算法），对解密得到的「上一次交易哈希值 + B 的公钥」重新计算哈希值，得到 “验证用哈希值”；
   比对确认：将 “验证用哈希值” 与 A 发来的「上一次交易哈希值」对比：
   若一致：证明交易未被篡改、是 A 真实发起，B 确认自己合法获得该货币；
   若不一致：交易存在篡改或伪造，B 拒绝认可该交易。
  注意：首次交易时对应创世块，无 “上一次交易哈希值”。创世块含初始设定等关键信息，发送者可用接收者公钥等处理交易，后续交易以此为基础形成交易链。

简化的支付验证:
 允许用户不运行完整节点，仅通过拥有最长工作量证明链的区块头副本，向其他节点查询确认最长链并获取交易对应的默克尔分支来验证支付；
 若交易已链接到链中，说明被网络节点接受，后续追加区块会进一步确认，不过这种验证在诚实节点控制网络时可靠，被攻击者控制则易受伪造交易欺骗，此时可借助其他节点的无效区块警告，下载全区块和相关交易检查来应对。

以太坊白皮书记录
 检查一个区块是否有效的算法，如以下范式所示：
  检查该区块引用的上一个区块是否存在且有效。
  检查该区块的时间戳是否大于上一个区块 [fn2]（注释编号）的时间戳并且在将来 2 小时以内
  检查区块上的工作量证明是否有效。
  令前一个区块末尾的态为 S[0]。
  假设 TX 是该区块的交易列表，其中包含 n 个交易。 对于 0...n-1 中的所有 i，如果有任何应用程序返回错误，退出并返回 false，请设置 S[i+1] = APPLY(S[i],TX[i])。
  返回 true，并将 S[n] 登记为该区块末尾的状态。

比特币是一个状态转换系统 状态转换函数 APPLY(S,TX) -> S' or ERROR
  举例
 未花币即 UTXO，使用规则如下：在比特币交易中，需用拥有者的 UTXO 来支付，这些 UTXO 总和要大于或等于支付金额。
比如 A 有两笔 UTXO，分别价值 3 比特币和 5 比特币，B 向 A 购买 4 比特币物品，A 可选择用价值 5 比特币的 UTXO 支付，
交易完成后，B 得到 4 比特币的新 UTXO，A 会收到 1 比特币找零的新 UTXO，同时旧的 UTXO 被消耗，且每笔交易都要通过状态转换函数验证 UTXO 使用的合法性 。
