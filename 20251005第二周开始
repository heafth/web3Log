fmt.Fprintln：功能灵活，支持任意实现 io.Writer 接口的输出目标（不止终端），比如：
打印到文件（*os.File）
打印到内存缓冲区（bytes.Buffer）
打印到网络连接（net.Conn）
同时支持对参数的格式化处理（虽然 Fprintln 本身不支持 % 占位符，但同系列的 fmt.Fprintf 支持）。

os.Stdout就是命令行窗口 / 终端窗口

编译好的二进制会存储在 $GOPATH/src/github.com/golang/go/bin 目录中

Go 语言的应用程序在运行之前需要先编译成二进制，在编译的过程中会经过中间代码生成阶段，Go 语言编译器的中间代码具有静态单赋值（Static Single Assignment、SSA）的特性
Go 源码 → 词法/语法分析 → AST → 中间表示（IR） → SSA 优化 → 汇编 → 机器码


   抽象语法树 树状的方式表示编程语言的语法结构 每一个节点都表示源代码中的一个元素 每一棵子树都表示一个语法元素
抽象语法树抹去了源代码中不重要的一些字符 - 空格、分号或者括号等

   静态单赋值是编译器在处理代码时采用的一种中间代码表示技术，其核心原则是让每个变量在中间代码中只被赋值一次。
作用是方便编译器分析代码数据流，进行常量传播、死代码消除等优化，提升生成代码的效率。（注意与java中的静态变量不同）

   指令集
  复杂指令集：通过增加指令的类型减少需要执行的指令数；
  精简指令集：使用更少的指令类型完成目标的计算任务；


   Go 语言编译器的源代码在 src/cmd/compile 目录中
  编译器的前端一般承担着词法分析、语法分析、类型检查和中间代码生成几部分工作，而编译器后端主要负责目标代码的生成和优化，也就是将中间代码翻译成目标机器能够运行的二进制机器码。
  Go 的编译器在逻辑上可以被分成四个阶段：词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和最后的机器代码生成

  词法解析器（lexer）词法分析的作用就是解析源代码文件，它将文件中的字符串序列转换成 Token 序列。
  语法分析的输入是词法分析器输出的 Token 序列，语法分析器会按照顺序解析 Token 序列

类型检查 #
  1.常量、类型和函数名及类型；
  2.变量的赋值和初始化；
  3.函数和闭包的主体；
  4.哈希键值对的类型；
  5.导入函数体；
  6.外部的声明；

中间代码生成 #
  当我们将源文件转换成了抽象语法树、对整棵树的语法进行解析并进行类型检查之后，就可以认为当前文件中的代码不存在语法错误和类型错误的问题了，Go 语言的编译器就会将输入的抽象语法树转换成中间代码


抽象语法树会经历类型检查、SSA 中间代码生成以及机器码生成三个阶段：

检查常量、类型和函数的类型；
   1.处理变量的赋值；
   2.对函数的主体进行类型检查；
   3.决定如何捕获变量；
   4.检查内联函数的类型；
   5.进行逃逸分析；
   6.将闭包的主体转换成引用的捕获变量；
   7.编译顶层函数；
   8.检查外部依赖的声明；


词法分析
  lex3 是用于生成词法分析器的工具
      .l 结尾的 lex 代码 -> C 语言代码 yy.c -> binary

早期的 Go 语言虽然使用 lex 这种工具来生成词法解析器，但是最后还是使用 Go 来实现词法分析器，用自己写的词法分析器来解析自己8。

语法分析 # 
  词法分析器输出的结果 — Token 序列是语法分析器的输入
N
 有限个非终结符的集合；
Σ
 有限个终结符的集合；
P
 有限个生产规则12的集合；
S
  非终结符集合中唯一的开始符号；
  语法树最顶层的结构或者开始符号都是 SourceFile

  顶层声明有五大类型，分别是常量、类型、变量、函数和方法，

类型检查 #
  强类型的编程语言在编译期间会有更严格的类型限制，也就是编译器会在编译期间发现变量赋值、返回值和函数调用时的类型错误；
  弱类型的编程语言在出现类型错误时可能会在运行时进行隐式的类型转换，在类型转换时可能会造成运行错误。

静态类型与动态类型
  1.静态类型检查是基于对源代码的分析来确定运行程序类型安全的过程3，如果我们的代码能够通过静态类型检查，
   那么当前程序在一定程度上可以满足类型安全的要求，它能够减少程序在运行时的类型检查，也可以被看作是一种代码优化的方式
  2.动态类型检查是在运行时确定程序类型安全的过程，它需要编程语言在编译时为所有的对象加入类型标签等信息，运行时可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性
