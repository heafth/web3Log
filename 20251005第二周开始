fmt.Fprintln：功能灵活，支持任意实现 io.Writer 接口的输出目标（不止终端），比如：
打印到文件（*os.File）
打印到内存缓冲区（bytes.Buffer）
打印到网络连接（net.Conn）
同时支持对参数的格式化处理（虽然 Fprintln 本身不支持 % 占位符，但同系列的 fmt.Fprintf 支持）。

os.Stdout就是命令行窗口 / 终端窗口

编译好的二进制会存储在 $GOPATH/src/github.com/golang/go/bin 目录中

Go 语言的应用程序在运行之前需要先编译成二进制，在编译的过程中会经过中间代码生成阶段，Go 语言编译器的中间代码具有静态单赋值（Static Single Assignment、SSA）的特性
Go 源码 → 词法/语法分析 → AST → 中间表示（IR） → SSA 优化 → 汇编 → 机器码


   抽象语法树 树状的方式表示编程语言的语法结构 每一个节点都表示源代码中的一个元素 每一棵子树都表示一个语法元素
抽象语法树抹去了源代码中不重要的一些字符 - 空格、分号或者括号等

   静态单赋值是编译器在处理代码时采用的一种中间代码表示技术，其核心原则是让每个变量在中间代码中只被赋值一次。
作用是方便编译器分析代码数据流，进行常量传播、死代码消除等优化，提升生成代码的效率。（注意与java中的静态变量不同）

   指令集
  复杂指令集：通过增加指令的类型减少需要执行的指令数；
  精简指令集：使用更少的指令类型完成目标的计算任务；


   Go 语言编译器的源代码在 src/cmd/compile 目录中
  编译器的前端一般承担着词法分析、语法分析、类型检查和中间代码生成几部分工作，而编译器后端主要负责目标代码的生成和优化，也就是将中间代码翻译成目标机器能够运行的二进制机器码。
  Go 的编译器在逻辑上可以被分成四个阶段：词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和最后的机器代码生成

  词法解析器（lexer）词法分析的作用就是解析源代码文件，它将文件中的字符串序列转换成 Token 序列。
  语法分析的输入是词法分析器输出的 Token 序列，语法分析器会按照顺序解析 Token 序列
