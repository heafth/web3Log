package main

import "fmt"

/* 自定义类型：与原类型 “完全独立”，不属于同一类型，编译时严格区分
反例（编译错误）：
var a int = 5; var b MyInt = 5; a = b（MyInt≠int，类型不匹配）
类型别名：与原类型 “完全等价”，仅名称不同，编译时视为同一类型
正例（合法）：
var a int = 5; var b IntAlias = 5; a = b（IntAlias 即 int，可直接赋值） */

//自定义类型用法示例
type Code int

//自定义别名示例
type intAlias = int

func (c Code) getMsg() string {
	switch c {
	case 0:
		return "成功"
	case 1001:
		return "服务器故障"
	case 1002:
		return "网络故障"
	}
	return "异常"
}

func (c Code) getCodeInfo() (code Code, CodeMsg string) {
	return c, c.getMsg()
}

const (
	SuccessCode    Code = 0
	ServerErrCode  Code = 1001
	NetWorkErrCode Code = 1002
)

func getInfo(name string) (code Code, CodeMsg string) {
	if name == "1" {
		return SuccessCode.getCodeInfo()
	}
	if name == "2" {
		return ServerErrCode.getCodeInfo()
	}
	if name == "3" {
		return NetWorkErrCode.getCodeInfo()
	}
	return 9999, "异常"
}

func main() {
	fmt.Println(getInfo("2"))
}

------------------------------------------------------------

package main

import "fmt"

//自定义类型和类型别名区别
type Autotype int
type AutoAlias = int

const autoType Autotype = 5
const autoAlias AutoAlias = 5

func main() {
	fmt.Printf("%v,%T\n", autoType, autoType)
	fmt.Printf("%v,%T\n", autoAlias, autoAlias)

	var age = 5
	//可以选择int(autoType) 或者 Autotype(age)
	if int(autoType) == age {
		fmt.Print("autoType需要强转后才等于age")
	}
	if autoAlias == age {
		fmt.Print("autoAlias等于age")
	}
}

-----------------------------------------------------

package main

import "fmt"

/* go语言接口特点：无需显式声明实现了某个接口，只要类型实现了接口的所有方法，就自动实现了该接口
   type 接口名 interface {
      方法名1(参数列表) 返回值列表
      方法名2(参数列表) 返回值列表
      ...更多方法
    }

   示例：定义一个可写接口
   type Writer interface {
      Write(data []byte) (int, error)
   }
*/

// 定义接口
type Animal interface {
	sing()
}

type Cat struct {
	Name string
}
type Duck struct {
	Name string
}

func (cat Cat) sing() {
	fmt.Println("喵")
}
func (duck Duck) sing() {
	fmt.Println("噶")
}

func animalSing(animal Animal) {
	//类型断言 可以判断传入对象是否属于当前结构体，示例中ch接收类信息，ok是bool值true表示是，false表示不是
	/*
		基础形式（可能触发 panic）：
		value := 接口变量.(目标类型)
	*/

	/*
		安全形式（推荐）：
		value, ok := 接口变量.(目标类型)
	*/

	var ch, ok = animal.(Cat)
	fmt.Println(ch, ok)

	//检查接口变量中实际存储的值是否为指定类型，如果是则返回该值；如果不是则触发 panic（除非使用带第二个返回值的形式）。
	switch yy := animal.(type) {
	case Cat:
		fmt.Println("yy", yy)
	case Duck:
		fmt.Println("yy", yy)
	default:
		fmt.Print("其他")
	}
	animal.sing()
}

/*
定义空接口:  空接口可以接受任何类型 换句话说 任何类型都实现了空接口
比如go自带的Print方法
这是 写法一
*/
type EmptyInterface interface{}

func CustomPrint1(ei EmptyInterface) {
	fmt.Println(ei)
}

/* 这是写法二 */
func CustomPrint2(ei interface{}) {
	fmt.Println(ei)
}

/* 这是写法三 */
func CustomPrint3(ei any) {
	fmt.Println(ei)
}

func main() {
	cat := Cat{Name: "猫"}
	animalSing(cat)

	duck := Duck{Name: "鸭子"}
	animalSing(duck)

	CustomPrint1(cat)
	CustomPrint1(duck)
}
