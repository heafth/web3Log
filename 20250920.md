package main

type Owner struct {
	id   int
	name string
}

func (o *Owner) Id() int {
	return o.id
}

func (o *Owner) Name() string {
	return o.name
}

func (o *Owner) SetId(id int) {
	o.id = id
}

func (o *Owner) SetName(name string) {
	o.name = name
}

func main() {
	var owner Owner
	owner.SetId(1)
	owner.SetName("张三")
	println("Owner ID:", owner.Id())
	println("Owner Name:", owner.Name())
}

注意：func (o *Owner) Id()  与   func (o Owner) Id() 不同在于
  getter 方法：通常用值接收者或指针接收者均可（因为不修改数据）
  setter 方法：必须用指针接收者（否则无法修改原结构体）
  对于大型结构体，优先使用指针接收者（避免频繁拷贝的性能损耗）
  在之前的示例中，如果把 Age() 改为值接收者，虽然仍能获取到年龄，但会产生结构体拷贝，没有必要。而 SetAge() 必须用指针接收者，否则无法真正修改年龄。

------------------------------------------------------------
练习
package main

import (
	"fmt"
	// "practice/study0005/studyCopilot"
)

func hello() {
	fmt.Println("Hello, Go!")
	fmt.Println("age =", age)
}

var age = 12

const keyword string = "123456"

// 定义多个变量
var (
	a3 = 3
	a4 = 4
)

package main

import (
	"fmt"
	copilot "practice/study/Copilot"
)

func hello() {
	fmt.Println("Hello, Go!")
	fmt.Println("age =", age)
}

var age = 12

const keyword string = "123456"

// 定义多个变量
var (
	a3 = 3
	a4 = 4
)

func main() {
	//先声明
	var name1 string
	//后赋值
	name1 = "张三"
	fmt.Println(name1)

	//声明并赋值
	var name2 string = "李四"
	fmt.Println(name2)

	//可以省略 string 自动推导类型
	var name3 = "王五"
	fmt.Println(name3)

	//声明并赋值 省略 var 自动推导类型
	name4 := "赵六"
	fmt.Println(name4)

	hello()

	//定义多个变量
	var a1, a2 = 1, 2
	fmt.Println(a1, a2)

	fmt.Println(a3, a4)

	fmt.Println("keyword =", keyword)

	fmt.Println(copilot.Version)
}


-------------------------------------------
package main

import "fmt"

func main() {
	var a = fmt.Sprintf("%2.1f	", 3.1415926)
	fmt.Println(a)

	var b int = 2
	fmt.Println(b)

	var c byte = 'c'
	fmt.Printf("%c, %d\n", c, c)

	//本质上rune是int32的别名
	//rune是Go语言中用于表示Unicode码点的类型
	//rune类型的变量占4个字节
	//rune类型的变量可以直接存储一个汉字
	var d rune = '中'
	fmt.Printf("%c, %d\n", d, d)

	fmt.Println("--------------")
	var age int
	var e bool
	var s string
	fmt.Printf("%#v\n", age)
	fmt.Printf("%#v\n", e)
	fmt.Printf("%#v\n", s)
}

------------------------------------------
关于%#v
package main

import "fmt"

type Student struct {
	Name string
	Age  int
}

//%#v 适合开发者调试（详细）
func main() {
	num := 123
	str := "go"
	s := Student{"张三", 20}
	arr := [3]int{1, 2, 3}

	// 用 %v 打印（只输出值）
	fmt.Printf("%%v 输出:\n")
	fmt.Printf("数字: %v\n", num)   // 数字: 123
	fmt.Printf("字符串: %v\n", str)  // 字符串: go
	fmt.Printf("结构体: %v\n", s)    // 结构体: {张三 20}
	fmt.Printf("数组: %v\n\n", arr) // 数组: [1 2 3]

	// 用 %#v 打印（输出类型+值）
	fmt.Printf("%%#v 输出:\n")
	fmt.Printf("数字: %#v\n", num)  // 数字: 123（基本类型值同%v，但复合类型差异大）
	fmt.Printf("字符串: %#v\n", str) // 字符串: "go"（带引号，明确是字符串）
	fmt.Printf("结构体: %#v\n", s)   // 结构体: main.Student{Name:"张三", Age:20}（显示类型和字段名）
	fmt.Printf("数组: %#v\n", arr)  // 数组: [3]int{1, 2, 3}（显示数组长度和类型）
}

-----------------------------------------------------

package main

import (
	"fmt"
	"sort"
)

func main() {
	var a [3]string = [3]string{"A", "B", "C"}
	fmt.Println(a[0], a[1], a[2])
	fmt.Println(a)

	//切片 slice
	b := []int{1, 2, 3, 4, 5}
	fmt.Println(b)
	fmt.Println(b[1:3])
	fmt.Println(b[2:])
	fmt.Println(b[:3])
	fmt.Println(b[:])

	var c []string = []string{"A", "B", "C"}
	c = append(c, "D")
	c = append(c, "E", "F", "G")
	fmt.Println(c)
	fmt.Println(len(c))
	fmt.Println()

	var d []string = make([]string, 0)
	fmt.Println(d == nil)

	var e []string
	fmt.Println(e == nil)

	f := make([]int, 3)
	fmt.Println(f)

	h := make([]string, 3)
	h[0] = "A"
	h[1] = "B"
	h[2] = "C"

	slice1 := h[0:2]
	slice2 := h[1:2]
	slice2[0] = "X"
	fmt.Println()
	fmt.Println(h)
	fmt.Println(slice1)
	fmt.Println(slice2)

	var i []int = []int{5, 2, 6, 3, 1, 4}
	//升序
	sort.Ints(i)
	fmt.Println(i)
	//降序
	sort.Sort(sort.Reverse(sort.IntSlice(i)))
	fmt.Println(i)
}
