1. lock.Lock()
阻塞式获取锁：
如果锁空闲 → 立即获得。
如果锁被别的 goroutine 持有 → 会阻塞等待，直到别人释放。
调用后，锁一定处于「已持有」状态。
2. lock.TryLock()（Go 1.18+）
非阻塞式获取锁：
如果锁空闲 → 立即获得，返回 true。
如果锁被别人持有 → 不会阻塞，直接返回 false。
调用后：
返回 true → 相当于 Lock() 成功，锁已被当前 goroutine 持有，必须 Unlock()。
返回 false → 什么都没发生，不需要 Unlock()。
package main

import (
	"fmt"
	"sync"
)

var sum int
var wait sync.WaitGroup
var lock sync.Mutex

func add() {
	lock.Lock()
	for i := 0; i < 10000; i++ {
		sum++
	}
	lock.Unlock()
	wait.Done()
}

func sub() {
	lock.Lock()
	//fmt.Println(lock.TryLock())
	for i := 0; i < 10000; i++ {
		sum--
	}
	lock.Unlock()
	//fmt.Println(lock.TryLock())
	wait.Done()
}

func main() {
	wait.Add(2)
	go add()
	go sub()
	wait.Wait()
	fmt.Println(sum)
}

-----------------------------------------------------

error 是内置接口类型，定义为 type error interface { Error() string }，任何实现 Error() 方法的类型都可作为错误。
作用：
表示程序运行中的非致命错误状态
用于函数间传递错误信息
是 Go 语言中处理预期错误的标准方式
核心特性：
需显式检查（不同于异常自动传播）
通常作为函数返回值的最后一个参数
与 panic 不同：error 用于可预期错误，panic 用于不可恢复的致命错误
创建方式：
errors.New(string)：创建简单错误
fmt.Errorf(string, ...)：创建格式化错误
自定义类型实现 Error() 方法：创建复杂错误
错误处理原则：
要么处理（修复 / 转换），要么传递（返回给上层）
避免忽略错误（除非明确知道安全）
Go 1.13+ 支持错误包装（%w 动词）和展开（errors.Unwrap）
与 panic 的区别：
error 是预期内的可处理错误，程序可继续执行
panic 是意外的致命错误，会终止正常流程（除非被 recover 捕获）

log.Fatalln​
归属：log包的函数，用于日志记录 + 程序退出​
行为：先打印日志（含时间戳，默认输出到标准错误），再调用os.Exit(1)终止程序，不执行 defer 语句​
panic​
归属：Go 语言内置关键字，用于触发运行时恐慌​
行为：立即终止当前函数执行，沿调用栈回溯执行所有defer语句，最终打印恐慌信息（错误信息、调用栈）并终止程序，退出码非 0

若需 “记录错误 + 优雅清理资源（如关闭文件、连接）”，用panic+recover，而非 log.Fatalln​
生产环境避免直接暴露 panic 原始信息，需用 recover 捕获并封装为友好错误提示​


recover 是内置函数，用于捕获 panic 引发的程序中断，使程序恢复正常执行流程 仅能在 defer 语句中有效工作 在错误发生后执行必要的清理操作

Go panic & recover 简明笔记
1️⃣ panic 的行为

panic 会 立即中断当前函数 的执行。

触发 panic 后，当前函数剩余代码 不再执行。

panic 会 沿调用栈向上冒泡，直到遇到 recover() 或程序终止。

2️⃣ defer + recover 的作用

recover() 只能在 defer 内捕获 panic。

recover 捕获 panic 后：

panic 停止冒泡，不会触发程序崩溃。

控制流不会回到 panic 发生点，函数内 panic 后的代码仍然不会执行。

3️⃣ recover 在不同位置的效果
recover 所在函数	panic 发生后代码	main 后续代码
main()	read() 内 panic 后代码不执行	main 内 panic 后代码也跳过
read()	read() 内 panic 后代码不执行	main 可以继续执行

总结规律：

panic 中断当前函数，recover 只能阻止冒泡。

谁捕获 panic，谁就结束冒泡，后续函数可以继续执行。

1. os.ReadFile
功能：简化版的文件读取函数，用于一次性读取整个文件的内容。
特点：
内部会自动完成「打开文件→读取内容→关闭文件」的完整流程，无需手动处理文件关闭。
只能用于读取文件（只读模式）。
返回值是 ([]byte, error)，直接得到文件内容的字节切片。
适用场景：快速读取小型文件的全部内容，代码简洁。

2. os.OpenFile
功能：更底层、更灵活的文件操作函数，支持自定义打开模式、权限等参数。
特点：
需要手动指定文件打开模式（如只读、只写、追加等）、权限（创建文件时）。
返回值是 (*os.File, error)，需要通过 *os.File 类型的方法（如 Read、Write、Close）进行读写和关闭。
支持复杂的文件操作（如分块读写、随机读写、文件锁等）。
适用场景：需要精细控制文件操作的场景（如大文件分块读取、写入、追加内容等）。
