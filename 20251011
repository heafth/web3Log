go语言结构体和指针实现接口：
 实现接口的类型	初始化变量类型	是否能通过	说明
 ✅ 结构体实现接口 (func (c Cat) Quack())	    ✅ 结构体值 Cat{}	  ✅ 通过	值实现接口，直接赋值没问题。
 ✅ 结构体实现接口 (func (c Cat) Quack())	    🔹结构体指针 &Cat{}	✅ 通过	指针可以自动解引用调用值方法。
 🔹结构体指针实现接口 (func (c *Cat) Quack())	✅ 结构体值 Cat{}	  ❌ 不通过	值不能自动取地址来满足接口实现。
 🔹结构体指针实现接口 (func (c *Cat) Quack())	🔹结构体指针 &Cat{}	✅ 通过	指针实现接口，指针赋值当然没问题。
 代码示例：
  func (c *Cat) Quack() { fmt.Println("喵") }
  var d Duck = Cat{} // ❌ 编译错误
 原因是Go 的方法集规则规定：
   值类型 T 的方法集 不包含 接收者是 *T 的方法；
   指针类型 *T 的方法集 包含 接收者是 T 和 *T 的所有方法。
 简而言之：
  指针可以实现“值方法接口”；
  值不能实现“指针方法接口”。
 我的个人总结就是 结构体初始变量 不能使用 结构体指针实现的接口



类型转换：
  //go:noinline 是 Go 编译器中的一种 编译器指令（compiler directive），不是普通注释。
 它告诉 Go 编译器：不要对接下来的这个函数或方法做“内联优化（inlining）”。
   那么什么又是go语言内联：
   在 Go 语言（以及大多数编译型语言）中，编译器在优化时会自动把一些小函数直接“展开”到调用点，而不生成真正的函数调用。
    例如：
    func Add(a, b int) int {
       return a + b
    }

    func main() {
       x := Add(1, 2)
    }

    内联优化结果：
    编译器可能会直接把 Add(1, 2) 替换为 x := 1 + 2


下面是这两节处理方式上的关键区别，以及背后的原因：
  方面	                                              指针接收者 → 指针类型赋给接口	                                                                 值接收者 → 结构体类型赋给接口
data 存什么	                                           data 存的是 *Cat（指向实例）	                                                         data 存的是一块内存里保存的 Cat 值（拷贝后的值）
拷贝行为	                                        不会拷贝整个结构体，只拷贝指针（原实例不拷贝）	                                                 会拷贝结构体的所有字段到新的内存（或复制值）
类型转换机制	                                  将 *Cat 转为接口时直接把指针 + itab 装入接口结构	                         通过 convT2I（或类似机制）做拷贝，把值拷贝到接口可管理的区域（可能堆或栈）然后装入接口结构
接口调用 / 方法指针查找	                  从 itab 拿出指向 (*Cat).Quack 的函数指针，然后 CALL，接收者就是 data（*Cat）	           从 itab 拿出指向 Cat.Quack 的函数指针，然后 CALL，接收者是那块存有 Cat 的 data 区域
性能 / 开销倾向	                    较小开销（只拷贝指针，不复制整个结构体），动态派发的额外开销在指针版本比较常见场景下较低	    较大开销，因为每次转换接口就得拷贝整个结构体，并且接口调用 + 值拷贝加动态派发叠加开销更高
编译器优化 / 静态化	                  作者指出编译器可能将 c.Quack() 优化成直接调用 (*Cat).Quack（静态化）以减少动态开销	                        同样也可能被优化成直接调用 Cat.Quack，减少查表开销
指针赋值给接口的兼容性	                 这种情况本来就是指针接收者 + 指针赋值给接口，是整节的主要例子	                         虽然是值接收者 + 值赋给接口的情形为主，但作者提到如果用指针（&Cat）赋给接口在这种接收者方式下也可以通过，
                                                                                                                                                编译器生成的汇编几乎与值赋给接口的相似
类型断言：
    调用形式	                    代码	                           调用的机制	                                                 本质区别
    接口调用	                  d.Quack()	                 动态分派（interface 动态调用）	            不知道类型的情况下，Go 会查找接口内部的 “itab” 方法表，定位到具体类型的实现，然后调用它。
    类型调用	                  c.Quack()	                     静态调用（直接调用）	                   断言已经把接口里的值提取成具体类型 *Cat，此时编译器知道它的真实类型了，直接静态调用。   


什么是动态派发：在面向对象 / 接口 /多态的语境中，指的是 在运行时决定调用哪个具体实现
  例如：
  type iface struct {
      tab  *itab       // 表示接口类型 + 具体类型的结合体（接口表 / 虚函数表）
      data unsafe.Pointer  // 指向具体对象（或者值的拷贝）的指针
  }
  itab 里有一个函数指针表（fun 数组），存放实现该接口的具体类型的各个方法的地址。也就是说，itab.fun[0] 就是这个接口的第一个方法对应具体类型的实现。 
  当你写 d.Quack()（d 是接口类型）时，在汇编 / 运行时层面是这么做的：
  1、从接口内部读取 tab（指向 itab 结构体）
  2、从 itab.fun[...] 拿到具体类型对应的 Quack 方法指针
  3、从 data 字段读取那个对象的地址 / 值
  4、将 data 作为接收者参数，调用 fun[...] 方法
  所以动态派发就是这个“查表 + 间接调用”的过程。
  在 Draven 的文章里，他还指出：有时候编译器优化会把这个动态过程“静态化”——也就是如果编译器在编译期能够推断出接口到底是哪一个具体类型，就直接编译成直接调用，跳过查表。 
                                                                                                                      
