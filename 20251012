反射三大法则:
  1、从 interface{} 变量可以反射出反射对象；
  2、从反射对象可以获取 interface{} 变量；
  3、要修改反射对象，其值必须可设置；


关于对于 reflect.TypeOf((*InterfaceType)(nil)).Elem() 的理解
  如果是这样写会报错：
    t := reflect.TypeOf(MyInterface) // ❌ 错误，编译不过  因为在 Go 里，MyInterface 是一个类型名，不是一个值
  于是“伪造”一个 MyInterface 类型的值
    重点理解这个：(*InterfaceType)(nil)
| 片段                     | 含义                                     |
| -----------------------  | -------------------------------         |
| `InterfaceType`          | 某个接口类型，比如 `error`、`MyInterface` |
| `*InterfaceType`         | “指向这个接口类型的指针类型”              |
| `nil`                    | 一个空指针值                             |
| `(*InterfaceType)(nil)`  | 把 `nil` 转换成“指向接口类型的指针”的值   |
   即是：  类型为 “指向接口类型的指针” 的 零值。 列如： var x *error = nil

关于Go 里三种“类型相关”的语法形式 防止混淆：
| 语法         | 名称                                   | 用途                                        | 举例                              |
| ---------   | ---------------------------------------| --------------------------------------------| ---------------------------------|
| `T(x)`      | **类型转换（type conversion）**         | 编译期转换一个值的类型（前提是类型兼容）        | `string(65)` → `"A"`             |
| `(*T)(x)`   | **类型断言中的“类型字面量”或指针转换**    | 要么是把 `x` 转成指针类型，要么是声明类型字面量 | `(*MyStruct)(nil)`               |
| `x.(T)`     | **类型断言（type assertion）**          | 在接口值上取出底层的具体类型                   | `i.(int)`、`v.Interface().(int)` |

实现协议：
   reflect.rtype.Implements 方法可以用于判断某些类型是否遵循特定的接口

方法调用：
    reflect.Value.Call 是运行时调用方法的入口，它通过两个 MustBe 开头的方法确定了当前反射对象的类型是函数以及可见性，
  随后调用 reflect.Value.call 完成方法调用，这个私有方法的执行过程会分成以下的几个部分：
   1、检查输入参数以及类型的合法性；
   2、将传入的 reflect.Value 参数数组设置到栈上；
   3、通过函数指针和输入参数调用函数；
   4、从栈上获取函数的返回值；

函数或者方法在调用时，所有的参数都会被依次放到栈上。

go语言中函数与方法的区别
| 特性            | 函数                     | 方法                                            |
| ---------------| -------------------------| ------------------------------------------------|
| 绑定类型        | 不绑定任何类型            | 绑定在类型上（接收者）                            |
| 调用方式        | `Add(1,2)`               | `x.Add(1)` 或 `(&x).Add(1)`                     |
| 是否可以修改原值 | 函数参数是普通值，按值传递 | 指针接收者可以修改原值                            |
| 是否可以作为值   | ✅ 可以直接赋值给变量     | ✅ 方法也是函数值，但如果绑定了接收者，类型要匹配  |
