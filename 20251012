反射三大法则:
  1、从 interface{} 变量可以反射出反射对象；
  2、从反射对象可以获取 interface{} 变量；
  3、要修改反射对象，其值必须可设置；


关于对于 reflect.TypeOf((*InterfaceType)(nil)).Elem() 的理解
  如果是这样写会报错：
    t := reflect.TypeOf(MyInterface) // ❌ 错误，编译不过  因为在 Go 里，MyInterface 是一个类型名，不是一个值
  于是“伪造”一个 MyInterface 类型的值
    重点理解这个：(*InterfaceType)(nil)
| 片段                     | 含义                                     |
| -----------------------  | -------------------------------         |
| `InterfaceType`          | 某个接口类型，比如 `error`、`MyInterface` |
| `*InterfaceType`         | “指向这个接口类型的指针类型”              |
| `nil`                    | 一个空指针值                             |
| `(*InterfaceType)(nil)`  | 把 `nil` 转换成“指向接口类型的指针”的值   |
   即是：  类型为 “指向接口类型的指针” 的 零值。 列如： var x *error = nil

关于Go 里三种“类型相关”的语法形式 防止混淆：
| 语法         | 名称                                   | 用途                                        | 举例                              |
| ---------   | ---------------------------------------| --------------------------------------------| ---------------------------------|
| `T(x)`      | **类型转换（type conversion）**         | 编译期转换一个值的类型（前提是类型兼容）        | `string(65)` → `"A"`             |
| `(*T)(x)`   | **类型断言中的“类型字面量”或指针转换**    | 要么是把 `x` 转成指针类型，要么是声明类型字面量 | `(*MyStruct)(nil)`               |
| `x.(T)`     | **类型断言（type assertion）**          | 在接口值上取出底层的具体类型                   | `i.(int)`、`v.Interface().(int)` |

实现协议：
   reflect.rtype.Implements 方法可以用于判断某些类型是否遵循特定的接口

方法调用：
    reflect.Value.Call 是运行时调用方法的入口，它通过两个 MustBe 开头的方法确定了当前反射对象的类型是函数以及可见性，
  随后调用 reflect.Value.call 完成方法调用，这个私有方法的执行过程会分成以下的几个部分：
   1、检查输入参数以及类型的合法性；
   2、将传入的 reflect.Value 参数数组设置到栈上；
   3、通过函数指针和输入参数调用函数；
   4、从栈上获取函数的返回值；

函数或者方法在调用时，所有的参数都会被依次放到栈上。

go语言中函数与方法的区别
| 特性            | 函数                     | 方法                                            |
| ---------------| -------------------------| ------------------------------------------------|
| 绑定类型        | 不绑定任何类型            | 绑定在类型上（接收者）                            |
| 调用方式        | `Add(1,2)`               | `x.Add(1)` 或 `(&x).Add(1)`                     |
| 是否可以修改原值 | 函数参数是普通值，按值传递 | 指针接收者可以修改原值                            |
| 是否可以作为值   | ✅ 可以直接赋值给变量     | ✅ 方法也是函数值，但如果绑定了接收者，类型要匹配  |

----------------------------------------------------------------------------------------------------------------------------

for 和 range：
range：
range 循环会在开始时固定迭代次数和索引范围。
 如果在range循环中使用append 增加元素不会影响当前循环的次数。（for中使用会无限循环）


关于：
func main() {
	arr := []int{1, 2, 3}
	newArr := []*int{}
	for _, v := range arr {
		newArr = append(newArr, &v)
	}
	for _, v := range newArr {
		fmt.Println(*v)
	}
}
书中说打印结果为 3 3 3，而我zaivscode中执行结构为 1 2 3
chatgpt解释为：
 循环变量 v
  在 早期 Go 版本（比如 Go 1.10 以前），v 的地址在循环中确实是复用的，所以 &v 会指向同一个变量 → 输出 3 3 3。
  Go 1.11 及之后版本，编译器做了优化：
    对于 每次迭代的 v，会在循环体中为 v 创建新的内存空间
    所以 &v 实际上每次迭代都是不同的地址 → 输出 1 2 3
  VSCode 的执行环境
    很可能你用的是 Go 1.18+ 或更高版本，因此 v 每次迭代都是新变量，所以 &v 不会复用 → 输出 [1 2 3]

遍历清空数组
 当我们想要在 Go 语言中清空一个切片或者哈希时，一般都会使用以下的方法将切片中的元素置零：
  func main() {
	  arr := []int{1, 2, 3}
	  for i, _ := range arr {
		  arr[i] = 0
	  }
  }


静态单赋值SSA在for循环中的运用
 for Ninit; Left; Right {
    NBody
 }
即是：
| 部分          | 编译器层面名字 | 作用                   | 例子               |
| -------       | -------      | ------------           | ---------------- |
| 初始化        | Ninit         | 循环开始前执行一次      | `i := 0`         |
| 条件          | Left         | 每次循环前判断是否继续   | `i < 10`         |
| 循环体末尾操作 | Right        | 每次循环体执行完后的更新 | `i++`            |
| 循环体        | NBody        | 循环内执行的语句         | `fmt.Println(i)` |

使用SSA的好处：
  SSA 是一种中间表示形式，每个变量在程序中只赋值一次。
  将循环拆分成 Ninit / Left / Right / NBody 有几个好处：
   1、循环分析更简单，优化更容易
   2、可以精确跟踪变量的生命周期
   3、便于做循环展开、向量化等优化
OFOR 的本质:（OFOR节点 即是 Ninit / Left / Right / NBody）
  OFOR 不是 Go 语言的关键字，它是 Go 编译器内部用的节点类型（AST/SSA 层面的概念）。
  作用：表示一个 for 循环，把循环拆解成便于编译器分析和优化的四部分。


