在 C 语言中，通常会用 寄存器 + 栈 的方式来传参与返回。
   在 x86_64 平台上，前 6 个整型或指针类型的参数通常对应放在 edi, esi, edx, ecx, r8d, r9d 等寄存器中。超过 6 个参数的，则会通过栈传递。
   返回值通常通过寄存器（比如 eax）传回调用方。
   这样的做法在性能上有优势（寄存器比内存/栈访问快），但实现复杂，因为要考虑寄存器分配、不同架构兼容、参数过多时的处理等。

Go 在这一节里分析了 Go 在编译后的汇编级别是怎样做的。结论是：
   Go 全部通过栈 来传递参数与返回值。也就是说，不像 C 那样混用寄存器 + 栈的方式。
   在调用函数前，调用方会在栈上为 返回值预留空间，也就是说调用者先在自己的栈帧上分配好空间，给被调用者写返回值的位置。
   参数入栈顺序一般是从右到左（也就是最右边的参数先压栈）——这是在很多语言中常见的约定。
   参数被压入栈中之后，才执行 CALL 指令跳转到被调用函数。然后被调用函数可以通过栈访问这些参数，并在返回前把结果写到预留好的返回值空间。
   当函数返回时，调用方清理栈、恢复栈指针、恢复基址指针（如 BP / 帧指针）等操作。
   相比 C，Go 这种全部用栈的方式简化了实现（不需要混合考虑寄存器分配规则，不同架构之间的寄存器差异问题少），但在性能上可能稍微有代价（因为栈访问比寄存器访问慢）

在 x86-64 架构（Go 默认的 ABI 也是这样）中，栈是从高地址向低地址增长的
高地址
  ↑
  │
  │  BP（基址指针）
  │  返回地址
  │  参数...
  │  局部变量...
  ↓
低地址

当文中说：
  参数的压栈顺序和 C 一样，都是从右到左。
  这句话的意思是：
  编译器在生成代码时，会先计算最右边的参数；
  然后把它先压栈；
  接着再压第二个参数；
  最左边的参数最后压栈。
 但栈是“向下长”的，所以先压的参数反而在内存的更高地址上。

 对于整型、布尔型、浮点型、数组这些类型，Go 在函数调用时都是按值传递:
   传值：函数调用时会对参数进行拷贝，被调用方和调用方两者持有不相关的两份数据；
   传引用：函数调用时会传递参数的指针，被调用方和调用方两者持有相同的数据，任意一方做出的修改都会影响另一方。
结构体:
 传递结构体时：会拷贝结构体中的全部内容；
 传递结构体指针时：会拷贝结构体指针；
