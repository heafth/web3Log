对于go语言中 * ，& 符号的理解和运用
1. 指针类型的情况
var vauto *[3]int
vauto 是一个“指向 [3]int 的指针”。
*vauto 解引用，表示“vauto 指向的那个数组”。

2. 普通变量（非指针类型）的情况
var vauto2 [3]int
这里 vauto2 就是一个 数组值，不是指针。

声明和初始化时：
 * 写在 类型 前：表示“这是个指针类型”。
 * 写在 变量或表达式 前：表示“解引用”，取指针指向的值。
 如果变量本身不是指针（例如 int、[3]int），那写 *变量 会直接报错。
在方法调用时：
 参数/接收者写成 *T，就是想让函数能修改调用者的值。
 调用方要传 &变量，或者 Go 编译器能帮你自动取地址。


*vauto = vstat → 拷贝数组内容。
    结果：堆上的那块 [3]int 内存现在和 vstat 内容一致。
         但是！它们是 两份独立的数组。
         改 vstat 不会影响 *vauto。
         改 *vauto 也不会影响 vstat。
vauto = &vstat → 改变指针指向。
    结果：vauto 不再指向堆上那份数组，而是直接指向 vstat。
         它们现在共享同一个数组。
         改 vstat 就会影响 *vauto。
         改 *vauto 也会影响 vstat。


2. Go 的内存分区
  1、代码区 (text segment)：程序的指令。
  2、全局/静态区 (data segment)：全局变量、常量。
  3、栈 (stack)：局部变量，函数调用。
  4、堆 (heap)：动态分配的对象，逃逸到堆的数据。



  大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要减少类似操作避免影响程序的性能


“逃逸”的直观理解
  没逃逸 → 变量生命周期只在函数内，用完函数结束就没了，可以放在栈上。
  逃逸了 → 变量在函数返回后还要被使用，必须放堆上交给 GC 管理。

切片扩容规则：
 1、运行时根据策略算出一个 newCap（可能就是 5，或者比 5 更大，取决于 oldCap 的情况）；
    策略： 如果期望容量大于当前容量的两倍就会使用期望容量；
          如果当前切片的长度小于 1024 就会将容量翻倍；
          如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；
 2、根据元素大小 (et.size) 计算所需字节 = newCap × et.size；
 3、再调用 roundUpSize（或类似机制）对这个字节数做向上对齐，使得分配更符合内存分配器的 size class 要求；
 4、最终新分配字节 / 元素大小 = 最终的 newCap（经对齐后的实际容量）。

切片拷贝规则：
  如果当前 copy 不是在运行时调用的runtime.memmove
  如果拷贝是在运行时发生的 编译器会使用 runtime.slicecopy 替换运行期间调用的 copy

----------------------------------------------------------------------------------

哈希冲突解决
  开放寻址法  依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中
  拉链法 每个哈希桶（数组索引）存储一个链表或类似的数据结构，当多个不同的 key 的哈希值相同时，它们都被放入同一个桶的链表中。

go语言hash初始化：
   字面量： 一般都会使用 key: value 的语法来表示键值对
      当哈希表中的元素数量少于或者等于 25 个时，编译器会将所有的键值对一次加入到哈希表中：
      一旦哈希表中元素的数量超过了 25 个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的 for 循环加入哈希
   运行时： 
