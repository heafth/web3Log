对于go语言中 * ，& 符号的理解和运用
1. 指针类型的情况
var vauto *[3]int
vauto 是一个“指向 [3]int 的指针”。
*vauto 解引用，表示“vauto 指向的那个数组”。

2. 普通变量（非指针类型）的情况
var vauto2 [3]int
这里 vauto2 就是一个 数组值，不是指针。

声明和初始化时：
 * 写在 类型 前：表示“这是个指针类型”。
 * 写在 变量或表达式 前：表示“解引用”，取指针指向的值。
 如果变量本身不是指针（例如 int、[3]int），那写 *变量 会直接报错。
在方法调用时：
 参数/接收者写成 *T，就是想让函数能修改调用者的值。
 调用方要传 &变量，或者 Go 编译器能帮你自动取地址。


*vauto = vstat → 拷贝数组内容。
    结果：堆上的那块 [3]int 内存现在和 vstat 内容一致。
         但是！它们是 两份独立的数组。
         改 vstat 不会影响 *vauto。
         改 *vauto 也不会影响 vstat。
vauto = &vstat → 改变指针指向。
    结果：vauto 不再指向堆上那份数组，而是直接指向 vstat。
         它们现在共享同一个数组。
         改 vstat 就会影响 *vauto。
         改 *vauto 也会影响 vstat。


2. Go 的内存分区
  1、代码区 (text segment)：程序的指令。
  2、全局/静态区 (data segment)：全局变量、常量。
  3、栈 (stack)：局部变量，函数调用。
  4、堆 (heap)：动态分配的对象，逃逸到堆的数据。



  大切片扩容或者复制时可能会发生大规模的内存拷贝，一定要减少类似操作避免影响程序的性能


“逃逸”的直观理解
  没逃逸 → 变量生命周期只在函数内，用完函数结束就没了，可以放在栈上。
  逃逸了 → 变量在函数返回后还要被使用，必须放堆上交给 GC 管理。

切片扩容规则：
 1、运行时根据策略算出一个 newCap（可能就是 5，或者比 5 更大，取决于 oldCap 的情况）；
    策略： 如果期望容量大于当前容量的两倍就会使用期望容量；
          如果当前切片的长度小于 1024 就会将容量翻倍；
          如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；
 2、根据元素大小 (et.size) 计算所需字节 = newCap × et.size；
 3、再调用 roundUpSize（或类似机制）对这个字节数做向上对齐，使得分配更符合内存分配器的 size class 要求；
 4、最终新分配字节 / 元素大小 = 最终的 newCap（经对齐后的实际容量）。

切片拷贝规则：
  如果当前 copy 不是在运行时调用的runtime.memmove
  如果拷贝是在运行时发生的 编译器会使用 runtime.slicecopy 替换运行期间调用的 copy

----------------------------------------------------------------------------------

哈希冲突解决
  开放寻址法  依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中
  拉链法 每个哈希桶（数组索引）存储一个链表或类似的数据结构，当多个不同的 key 的哈希值相同时，它们都被放入同一个桶的链表中。

go语言hash初始化：
   字面量： 一般都会使用 key: value 的语法来表示键值对
      当哈希表中的元素数量少于或者等于 25 个时，编译器会将所有的键值对一次加入到哈希表中：
      一旦哈希表中元素的数量超过了 25 个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的 for 循环加入哈希
   运行时： 
     当我们使用 make(map[K]V, hint) 或其它方式动态创建 map 时，会在程序运行时调用 runtime.makemap 来完成初始化。
　　   该函数会：
　　    - 根据容量提示 hint 计算合适的桶数量（桶数 = 2^B）；
　　    - 分配并初始化一个 hmap 结构体；
　    　- 设置随机哈希种子 hash0（用于防止哈希碰撞攻击）；
　    　- 调用 makeBucketArray 分配桶数组，并可能预留溢出桶空间；
　    　- 返回初始化完成的 map，供后续插入和访问操作使用。
　    　另外，对于非常小的 map，编译器可能会直接在栈上分配一个 hmap 和单个桶，以减少堆分配的开销。

哈希扩容
  条件： 
   总的元素数 / 桶数（即装载因子，load factor）变得太大，或者
   溢出桶（overflow buckets）数量太多
     所以 Go 的 map 在这些条件触发时会 扩容，也就是增加桶的数量，把现有的键值对“重新分配”（重新哈希到新的桶里）
     扩容不是一次性把所有东西搬过去，而是在插入时渐进地搬（增量搬迁），以避免一次性延迟过大。
  核心：
     扩容就是给 B 加一（令桶数翻倍或按需要）并创建新的 buckets，同时保留旧的 oldbuckets。然后逐步把旧桶中的元素搬到新的桶中

 Go 会在 mapassign（插入操作）里检查是否要扩容，条件包括：
    装载因子超出阈值（Go 用的一个临界值，大致是每个桶装满率过高）
    溢出桶太多（说明某些桶已经频繁 overflow，意味着哈希分布不均或冲突严重）
   当满足扩容条件时，会调用 hashGrow 来做扩容准备
 扩容的过程（重分配 / 搬迁 / 增量迁移）：
   4.1 创建新的桶（和旧桶保留）
     hashGrow 做的事情：
     决定新的 B 值（桶数增多，通常翻倍）
     用 makeBucketArray 分配一块新的桶数组（buckets）和可能的溢出桶预留空间。
     把旧的 buckets（原来的桶数组）放入 oldbuckets 字段保存。
     初始化一些辅助字段（比如 nevacuate = 0，用来标记旧桶被迁移的进度）
     此时，map 虽然“扩容”了（有新的桶数组），但旧桶里的内容还没被搬。访问和写入时还要兼顾旧桶。
   4.2 迁移旧桶内容（evacuate）
     旧桶的数据不能马上全部复制过去（那样一次代价太大），Go 用 增量迁移：每次插入或访问的时候，顺带搬迁一部分桶的数据。
     迁移逻辑的关键点：
     对于一个旧桶（oldbucket），evacuate 函数会把这个桶里的每个键值对重新哈希一次，决定该放到新桶数组中的哪个桶。
     有一个“newbit”用来判断键应落在哪个新的桶上：原来的桶可能会分布到两个新的桶中（原桶号和 + oldbuckets 的那个）
     分流（re-distribute）：若哈希 & newbit == 0，留在原桶号的新位置；否则去新的那个桶。
     旧桶中键值对搬走之后，会在旧桶标记为“已迁移”（evacuated），不再从旧桶读取。
     这样，随着新插入或访问操作，旧桶一个个被“清空搬迁”到新的桶里，最终所有旧桶都搬好之后，就可以丢弃 oldbuckets。
   4.3 同时访问时的兼容处理
     在扩容过程中，既不能只访问新桶（因为旧桶的数据还没搬完），也不能只访问旧桶。Go 在 mapaccess1 / mapaccess2 中就做了兼顾处理：
    如果 oldbuckets != nil，还没迁移的桶仍可能被访问；访问逻辑要看该键所在的桶是否已经被迁移（evacuated）
    写入时也会触发 growWork（在插入的时候做一部分桶迁移工作）

| 项目      | 含义       | 是否唯一     | 查找作用     |
| 哈希低位   | 决定桶号  | 相同（同桶）  | 定位桶       |
| tophash   | 哈希高 8 位  | 不同也行   | 桶内快速过滤  |
| key 本身  | 唯一标识    | 唯一        | 精确匹配     |


哈希删除： 
   如果哈希表删除某键值对的时候遇到扩容：
     1.先把旧桶的所有元素搬到新桶对应位置（split bucket）。
     2.搬完后再在新桶中删除目标键。
